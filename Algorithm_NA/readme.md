# 그리디 알고리즘
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법.
- 매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다. 
- 일반적으로 '사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형’이라는 특징이 있다.
- 그리디 알고리즘은 기준에 따라 좋은 것을 선택히는 알고리즘이므로, 문제에서 ‘가장 큰 순서대로’，‘가장 작은 순서대로’와 같은 기준을 알게 모르게 제시해준다. 

# 구현
흔히 풀이법을 떠올리기는 쉽지만, 소스코드로 옮기기 어려운 문제를 구현으로 분류
- 완전 탐색: 모든 경우의 수를 전부 계산하여 해결하는 방법
- 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제 유형을 의미한다.
- 일반적으로 지문이 길어 파악하는데 시간이 소요되며, 적절한 라이브러리를 활용할 줄 안다면 보다 쉽게 풀 수 있는 경우가 많다.

# 스택과 큐
탐색을 이해하려면 -> DFS, BFS 알아야 한다 -> 이를 알기 위해 스택과 큐 자료구조에 익숙해야 한다.
### 스택 : 선입후출 구조
파이썬에서 스택은 별도의 라이브러리 없이 파이썬 리스트를 활용하여 구현 가능

### 큐 : 선입 선출 구조. 대기줄에 비유할 수 있다.
from collections import deque

# DFS
인접 행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식 (파이썬 2차원 배열로 구현)
인접 리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식 (연결 리스트 자료구조를 이용하여 구현)

관련 적절한 비유: 넷플릭스에서 드라마 시청하고자 할 때, DFS는 하나의 시리즈를 정주행하는 것, BFS는 여러 시리즈를 한 화 씩 번갈아 보는 것으로 비유할 수 있다.

DFS는 깊이 우선 탐색이라고도 부르고, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

DFS는 스택 자료구조 (혹은 재귀함수)를 바탕으로 구현되며, 구체적인 동작은 아래와 같다.
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다. (스택에 쌓여있는 건, 확인을 해봐야할 노드)
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라고 있다면, 그 노드를 스택에 넣고 방문 처리 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. (.pop)
3. 더 이상 2번의 과정을 수행할 수 없을 떄까지 반복한다.

그런데 실제로는 스택이 없이도 구현 가능하며, 이때 시간 복잡도 O(N)

# BFS
BFS는 너비 우선 탐색이라고 불리며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.

BFS는 큐 자료구조를 활용하여 구현되며, 구체적인 동작은 아래와 같다.
1. 탐색 시작 노드를 큐에 넣고 방문 처리한다.
2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다.
3. 더 이상 2번의 과정을 수행할 수 없을 떄까지 반복한다.

시간 복잡도는 O(N)이며, 실제 수행 시간이 일반적으로 DFS에 비해 좋은 편이라는 것을 알면 좋다.

설계할 때 그래프(노드 별 연결 정보)를 어떻게 설계할지 먼저 구상한 뒤, 탐색 함수를 설계해야 한다.

